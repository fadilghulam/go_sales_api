// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package generated

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"go_sales_api/internal/model"
)

func newDiscount(db *gorm.DB, opts ...gen.DOOption) discount {
	_discount := discount{}

	_discount.discountDo.UseDB(db, opts...)
	_discount.discountDo.UseModel(&model.Discount{})

	tableName := _discount.discountDo.TableName()
	_discount.ALL = field.NewAsterisk(tableName)
	_discount.ID = field.NewInt64(tableName, "id")
	_discount.Qty = field.NewInt64(tableName, "qty")
	_discount.Type = field.NewString(tableName, "type")
	_discount.Result = field.NewInt64(tableName, "result")
	_discount.ExpiredAt = field.NewInt64(tableName, "expired_at")
	_discount.ExpiredAtFormat = field.NewString(tableName, "expired_at_format")
	_discount.StringFormat = field.NewString(tableName, "string_format")
	_discount.CreatedAt = field.NewTime(tableName, "created_at")
	_discount.UpdatedAt = field.NewTime(tableName, "updated_at")

	_discount.fillFieldMap()

	return _discount
}

type discount struct {
	discountDo

	ALL             field.Asterisk
	ID              field.Int64
	Qty             field.Int64
	Type            field.String
	Result          field.Int64
	ExpiredAt       field.Int64
	ExpiredAtFormat field.String
	StringFormat    field.String
	CreatedAt       field.Time
	UpdatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (d discount) Table(newTableName string) *discount {
	d.discountDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d discount) As(alias string) *discount {
	d.discountDo.DO = *(d.discountDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *discount) updateTableName(table string) *discount {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.Qty = field.NewInt64(table, "qty")
	d.Type = field.NewString(table, "type")
	d.Result = field.NewInt64(table, "result")
	d.ExpiredAt = field.NewInt64(table, "expired_at")
	d.ExpiredAtFormat = field.NewString(table, "expired_at_format")
	d.StringFormat = field.NewString(table, "string_format")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")

	d.fillFieldMap()

	return d
}

func (d *discount) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *discount) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 9)
	d.fieldMap["id"] = d.ID
	d.fieldMap["qty"] = d.Qty
	d.fieldMap["type"] = d.Type
	d.fieldMap["result"] = d.Result
	d.fieldMap["expired_at"] = d.ExpiredAt
	d.fieldMap["expired_at_format"] = d.ExpiredAtFormat
	d.fieldMap["string_format"] = d.StringFormat
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
}

func (d discount) clone(db *gorm.DB) discount {
	d.discountDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d discount) replaceDB(db *gorm.DB) discount {
	d.discountDo.ReplaceDB(db)
	return d
}

type discountDo struct{ gen.DO }

type IDiscountDo interface {
	gen.SubQuery
	Debug() IDiscountDo
	WithContext(ctx context.Context) IDiscountDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDiscountDo
	WriteDB() IDiscountDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDiscountDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDiscountDo
	Not(conds ...gen.Condition) IDiscountDo
	Or(conds ...gen.Condition) IDiscountDo
	Select(conds ...field.Expr) IDiscountDo
	Where(conds ...gen.Condition) IDiscountDo
	Order(conds ...field.Expr) IDiscountDo
	Distinct(cols ...field.Expr) IDiscountDo
	Omit(cols ...field.Expr) IDiscountDo
	Join(table schema.Tabler, on ...field.Expr) IDiscountDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDiscountDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDiscountDo
	Group(cols ...field.Expr) IDiscountDo
	Having(conds ...gen.Condition) IDiscountDo
	Limit(limit int) IDiscountDo
	Offset(offset int) IDiscountDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDiscountDo
	Unscoped() IDiscountDo
	Create(values ...*model.Discount) error
	CreateInBatches(values []*model.Discount, batchSize int) error
	Save(values ...*model.Discount) error
	First() (*model.Discount, error)
	Take() (*model.Discount, error)
	Last() (*model.Discount, error)
	Find() ([]*model.Discount, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Discount, err error)
	FindInBatches(result *[]*model.Discount, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Discount) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDiscountDo
	Assign(attrs ...field.AssignExpr) IDiscountDo
	Joins(fields ...field.RelationField) IDiscountDo
	Preload(fields ...field.RelationField) IDiscountDo
	FirstOrInit() (*model.Discount, error)
	FirstOrCreate() (*model.Discount, error)
	FindByPage(offset int, limit int) (result []*model.Discount, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDiscountDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d discountDo) Debug() IDiscountDo {
	return d.withDO(d.DO.Debug())
}

func (d discountDo) WithContext(ctx context.Context) IDiscountDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d discountDo) ReadDB() IDiscountDo {
	return d.Clauses(dbresolver.Read)
}

func (d discountDo) WriteDB() IDiscountDo {
	return d.Clauses(dbresolver.Write)
}

func (d discountDo) Session(config *gorm.Session) IDiscountDo {
	return d.withDO(d.DO.Session(config))
}

func (d discountDo) Clauses(conds ...clause.Expression) IDiscountDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d discountDo) Returning(value interface{}, columns ...string) IDiscountDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d discountDo) Not(conds ...gen.Condition) IDiscountDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d discountDo) Or(conds ...gen.Condition) IDiscountDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d discountDo) Select(conds ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d discountDo) Where(conds ...gen.Condition) IDiscountDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d discountDo) Order(conds ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d discountDo) Distinct(cols ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d discountDo) Omit(cols ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d discountDo) Join(table schema.Tabler, on ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d discountDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d discountDo) RightJoin(table schema.Tabler, on ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d discountDo) Group(cols ...field.Expr) IDiscountDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d discountDo) Having(conds ...gen.Condition) IDiscountDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d discountDo) Limit(limit int) IDiscountDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d discountDo) Offset(offset int) IDiscountDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d discountDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDiscountDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d discountDo) Unscoped() IDiscountDo {
	return d.withDO(d.DO.Unscoped())
}

func (d discountDo) Create(values ...*model.Discount) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d discountDo) CreateInBatches(values []*model.Discount, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d discountDo) Save(values ...*model.Discount) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d discountDo) First() (*model.Discount, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Discount), nil
	}
}

func (d discountDo) Take() (*model.Discount, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Discount), nil
	}
}

func (d discountDo) Last() (*model.Discount, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Discount), nil
	}
}

func (d discountDo) Find() ([]*model.Discount, error) {
	result, err := d.DO.Find()
	return result.([]*model.Discount), err
}

func (d discountDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Discount, err error) {
	buf := make([]*model.Discount, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d discountDo) FindInBatches(result *[]*model.Discount, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d discountDo) Attrs(attrs ...field.AssignExpr) IDiscountDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d discountDo) Assign(attrs ...field.AssignExpr) IDiscountDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d discountDo) Joins(fields ...field.RelationField) IDiscountDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d discountDo) Preload(fields ...field.RelationField) IDiscountDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d discountDo) FirstOrInit() (*model.Discount, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Discount), nil
	}
}

func (d discountDo) FirstOrCreate() (*model.Discount, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Discount), nil
	}
}

func (d discountDo) FindByPage(offset int, limit int) (result []*model.Discount, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d discountDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d discountDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d discountDo) Delete(models ...*model.Discount) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *discountDo) withDO(do gen.Dao) *discountDo {
	d.DO = *do.(*gen.DO)
	return d
}
